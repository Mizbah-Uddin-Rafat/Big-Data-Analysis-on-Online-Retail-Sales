# -*- coding: utf-8 -*-
"""604IT CW2 Program File

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/mizbahuddinrafat/604it-cw2-program-file.19834393-938c-4f06-a678-fa55640d44e6.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20250711/auto/storage/goog4_request%26X-Goog-Date%3D20250711T113750Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3Daf9cc5f033b3282f5a7eac09c35a9ab1e716f1b2884c4f3d4cf28ec632e60311027a9f78d31c2ce34c56f209a569b13b147bb90eacdb49035ca6eb6a86538f442df451b3501903b5e669dfba73ca29d8ddc3297fa761fb6c02a3b7a846b9b7bda340b4b9aa390a0d249ea815249df74f91ce7467648eb915fa450679212aaacfea780fd1d11fa06723462b7358ba7435dd4abced1e4821bbff66f0fe92051a1ffee770fd8680d599731a269679cd669d3d87aab51031d4bfee728bc1a1260105b58dc59f3e5a0ba7874e9de07eb53c76c583b7ccf4c6ddd0f22ead0da84650c5c8c63a99bd105f5b1f7ecec517f6e8dbad617ae0056b04ce057d07e0aa883ac9
"""

# IMPORTANT: SOME KAGGLE DATA SOURCES ARE PRIVATE
# RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES.
import kagglehub
kagglehub.login()

# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.

mizbahuddinrafat_retail_dataset_path = kagglehub.dataset_download('mizbahuddinrafat/retail-dataset')
varshnidevi_ecommerce_behavior_data_from_multi_category_store_path = kagglehub.notebook_output_download('varshnidevi/ecommerce-behavior-data-from-multi-category-store')

print('Data source import complete.')

import pandas as pd

df = pd.read_csv("/kaggle/input/retail-dataset/online_retail_II.csv",encoding='ISO-8859-1')
df.info()
df.describe

df.columns

df.shape

df.head(10)

"""Handling Missing Values"""

rows_before = len(df)
df = df.dropna(subset=['Customer ID'])
print(f"Removed {rows_before - len(df)} rows with missing Customer ID.")

""" Removing Invalid Transactions"""

rows_before = len(df)
df = df[(df['Quantity'] > 0) & (df['Price'] > 0)]
print(f"Removed {rows_before - len(df)} rows with non-positive Quantity or Price.")

df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'],dayfirst=True)
df = df.copy()
df['Month'] = df['InvoiceDate'].dt.month
df['DayOfWeek'] = df['InvoiceDate'].dt.day_name()
df['Hour'] = df['InvoiceDate'].dt.hour
df = df.copy()
df['TotalPrice'] = df['Quantity'] * df['Price']

rows_before = len(df)
df.drop_duplicates(inplace=True)
print(f"Removed {rows_before - len(df)} duplicate rows.")

import dask.dataframe as dd
ddf = dd.read_csv('/kaggle/input/retail-dataset/online_retail_II.csv',sample =10000000000000,
                  encoding='cp1252',
                 dtype={
        'Customer ID': 'float64',
        'Invoice': 'object' }
    ,)

ddf.head(10)

""" Exploratory Data Analysis (Pandas)"""

#Monthly Sales
monthly_sales = df.groupby('Month')['TotalPrice'].sum()
print("Monthly sales:", monthly_sales)

import matplotlib.pyplot as plt
import seaborn as sns

# Reset index for plotting
monthly_sales_df = monthly_sales.reset_index()

# Plot
plt.figure(figsize=(10, 6))
sns.barplot(data=monthly_sales_df, x='Month', y='TotalPrice', palette='Blues_d')
plt.title('Total Monthly Sales')
plt.xlabel('Month')
plt.ylabel('Total Sales (£)')
plt.xticks(ticks=range(0, 12), labels=[
    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
])
plt.tight_layout()
plt.show()

#Top 10 Products
top_products = df.groupby('Description')['Quantity'].sum().sort_values(ascending=False).head(10)
print("\nTop Products:\n", top_products)

import matplotlib.pyplot as plt

# Pie chart
plt.figure(figsize=(8, 8))
plt.pie(
    top_products.values,
    labels=top_products.index,
    autopct='%1.1f%%',
    startangle=140,
    colors=sns.color_palette('pastel'),
    wedgeprops={'edgecolor': 'black'}
)
plt.title('Top 10 Products – Share of Total Quantity Sold', fontsize=14)
plt.tight_layout()
plt.show()

"""Customer Segmentation: RFM + K-Means"""

snapshot_date = df['InvoiceDate'].max() + pd.Timedelta(days=1)
rfm = df.groupby('Customer ID').agg({
    'InvoiceDate': lambda x: (snapshot_date - x.max()).days,
    'Invoice': 'nunique',
    'TotalPrice': 'sum'
}).rename(columns={'InvoiceDate': 'Recency', 'Invoice': 'Frequency', 'TotalPrice': 'Monetary'})

# Clustering
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
import numpy as np

rfm_log = np.log1p(rfm)
rfm_scaled = StandardScaler().fit_transform(rfm_log)
kmeans = KMeans(n_clusters=4, random_state=42)
rfm['Cluster'] = kmeans.fit_predict(rfm_scaled)
print(rfm.groupby('Cluster').mean())
print(rfm['Cluster'])

from sklearn.metrics import silhouette_score

# RFM Clustering (your existing code)
snapshot_date = df['InvoiceDate'].max() + pd.Timedelta(days=1)
rfm = df.groupby('Customer ID').agg({
    'InvoiceDate': lambda x: (snapshot_date - x.max()).days,
    'Invoice': 'nunique',
    'TotalPrice': 'sum'
}).rename(columns={'InvoiceDate': 'Recency', 'Invoice': 'Frequency', 'TotalPrice': 'Monetary'})

# Preprocessing
from sklearn.preprocessing import StandardScaler
import numpy as np

rfm_log = np.log1p(rfm)
rfm_scaled = StandardScaler().fit_transform(rfm_log)

# KMeans Clustering
from sklearn.cluster import KMeans

kmeans = KMeans(n_clusters=4, random_state=42)
rfm['Cluster'] = kmeans.fit_predict(rfm_scaled)

# Calculate Silhouette Score
score = silhouette_score(rfm_scaled, rfm['Cluster'])
print(f"Silhouette Score: {score:.4f}")

import matplotlib.pyplot as plt
from sklearn.cluster import KMeans

# Elbow Method
wcss = []
for k in range(1, 11):
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(rfm_scaled)
    wcss.append(kmeans.inertia_)

plt.figure(figsize=(8, 5))
plt.plot(range(1, 11), wcss, marker='o')
plt.title('Elbow Method for Optimal Clusters')
plt.xlabel('Number of clusters')
plt.ylabel('WCSS')
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 6))
sns.scatterplot(
    data=rfm.reset_index(),
    x='Recency',
    y='Monetary',
    hue='Cluster',
    palette='tab10',
    alpha=0.8,
    edgecolor='w',
    s=100
)
plt.title('RFM Clustering: Recency vs Monetary', fontsize=16)
plt.xlabel('Recency (days)')
plt.ylabel('Monetary Value (£)')
plt.legend(title='Cluster', bbox_to_anchor=(1.05, 1), loc='upper left')
sns.despine()
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 6))
sns.scatterplot(
    data=rfm.reset_index(),
    x='Frequency',
    y='Monetary',
    size='Recency',
    hue='Cluster',
    palette='Set2',
    sizes=(20, 600),
    alpha=0.7,
    edgecolor='black'
)
plt.title('Bubble Chart of RFM Clusters', fontsize=16)
plt.xlabel('Frequency')
plt.ylabel('Monetary Value (£)')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
sns.despine()
plt.tight_layout()
plt.show()

"""Sales Forecasting (Linear Regression)"""

import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import train_test_split

df = pd.read_csv('/kaggle/input/retail-dataset/online_retail_II.csv', encoding='latin1', parse_dates=['InvoiceDate'], dayfirst=True)
df['TotalPrice'] = df['Quantity'] * df['Price']

# Feature Engineering - Monthly Aggregation
monthly_sales = df.set_index('InvoiceDate').resample('ME').agg({
    'TotalPrice': 'sum',
    'Quantity': 'sum',
    'Invoice': 'nunique',
    'Customer ID': 'nunique'
}).reset_index()
monthly_sales.columns = ['Date', 'Sales', 'TotalQuantity', 'TransactionCount', 'UniqueCustomers']


monthly_sales['Month'] = monthly_sales['Date'].dt.month
monthly_sales['Year'] = monthly_sales['Date'].dt.year
monthly_sales['DaysInMonth'] = monthly_sales['Date'].dt.days_in_month
monthly_sales['SalesPerTransaction'] = monthly_sales['Sales'] / monthly_sales['TransactionCount']

# Lag features
monthly_sales = monthly_sales.sort_values('Date')
monthly_sales['PrevMonthSales'] = monthly_sales['Sales'].shift(1)
monthly_sales = monthly_sales.dropna()

X = monthly_sales[['Month', 'Year', 'TransactionCount', 'UniqueCustomers', 'PrevMonthSales']]
y = monthly_sales['Sales']

split_idx = int(len(X) * 0.8)
X_train, X_test = X.iloc[:split_idx], X.iloc[split_idx:]
y_train, y_test = y.iloc[:split_idx], y.iloc[split_idx:]

model = LinearRegression()
model.fit(X_train, y_train)

y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
print(f"MSE: {mse:.2f}")

print(f"R² Score: {r2_score(y_test, y_pred):.4f}")

# Feature importance
coefficients = pd.DataFrame({
    'Feature': X.columns,
    'Importance': model.coef_
}).sort_values('Importance', key=abs, ascending=False)
print("\nFeature Importance:\n", coefficients)

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

# Load and preprocess data
df = pd.read_csv('/kaggle/input/retail-dataset/online_retail_II.csv', encoding='latin1', parse_dates=['InvoiceDate'], dayfirst=True)
df['TotalPrice'] = df['Quantity'] * df['Price']

monthly_sales = df.set_index('InvoiceDate').resample('ME').agg({
    'TotalPrice': 'sum',
    'Quantity': 'sum',
    'Invoice': 'nunique',
    'Customer ID': 'nunique'
}).reset_index()

monthly_sales.columns = ['Date', 'Sales', 'TotalQuantity', 'TransactionCount', 'UniqueCustomers']
monthly_sales['Month'] = monthly_sales['Date'].dt.month
monthly_sales['Year'] = monthly_sales['Date'].dt.year
monthly_sales['DaysInMonth'] = monthly_sales['Date'].dt.days_in_month
monthly_sales['SalesPerTransaction'] = monthly_sales['Sales'] / monthly_sales['TransactionCount']
monthly_sales = monthly_sales.sort_values('Date')
monthly_sales['PrevMonthSales'] = monthly_sales['Sales'].shift(1)
monthly_sales = monthly_sales.dropna()

# Model training
X = monthly_sales[['Month', 'Year', 'TransactionCount', 'UniqueCustomers', 'PrevMonthSales']]
y = monthly_sales['Sales']
model = LinearRegression()
model.fit(X, y)

# Create 6 future months for forecasting
last_date = monthly_sales['Date'].max()
future_dates = pd.date_range(last_date + pd.offsets.MonthEnd(1), periods=6, freq='M')
future_df = pd.DataFrame({'Date': future_dates})
future_df['Month'] = future_df['Date'].dt.month
future_df['Year'] = future_df['Date'].dt.year
future_df['DaysInMonth'] = future_df['Date'].dt.days_in_month

# Use average of last 3 months for placeholders
last_values = monthly_sales.tail(3)
future_df['TransactionCount'] = last_values['TransactionCount'].mean()
future_df['UniqueCustomers'] = last_values['UniqueCustomers'].mean()

# Use previous month’s actual sales for forecasting
prev_sales = monthly_sales['Sales'].iloc[-1]
future_df['PrevMonthSales'] = 0.0
for i in range(len(future_df)):
    future_df.loc[i, 'PrevMonthSales'] = prev_sales
    features = future_df.loc[i, ['Month', 'Year', 'TransactionCount', 'UniqueCustomers', 'PrevMonthSales']].values.reshape(1, -1)
    prediction = model.predict(features)[0]
    prev_sales = prediction
    future_df.loc[i, 'Sales'] = prediction

# Combine historical and forecasted data
forecasted = future_df[['Date', 'Sales']]
combined = pd.concat([monthly_sales[['Date', 'Sales']], forecasted])

# Plotting
plt.figure(figsize=(12, 6))
plt.plot(combined['Date'], combined['Sales'], label='Historical + Forecasted Sales', marker='o')
plt.axvline(x=monthly_sales['Date'].max(), color='red', linestyle='--', label='Forecast Start')
plt.title('Monthly Sales Forecast (6 Months)')
plt.xlabel('Date')
plt.ylabel('Sales')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

"""Geographic Analysis"""

country_sales = df.groupby('Country')['Price'].sum().sort_values(ascending=False)
print(country_sales)

import plotly.express as px
import pandas as pd

# Prepare data (assumes 'Country' and 'Price' are in country_sales_df)
country_sales_df = country_sales.reset_index()
country_sales_df.columns = ['Country', 'Sales']

# Plot
fig = px.choropleth(
    country_sales_df,
    locations='Country',
    locationmode='country names',
    color='Sales',
    color_continuous_scale='Blues',
    title='Global Sales Distribution by Country',
)

fig.update_layout(
    geo=dict(showframe=False, showcoastlines=False),
    coloraxis_colorbar=dict(title='Total Sales (£)')
)

fig.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Group and sort country sales
country_sales = df.groupby('Country')['Price'].sum().sort_values(ascending=False)

# Plot top 20 countries for clarity
top_countries = country_sales.head(20).reset_index()

plt.figure(figsize=(12, 8))
sns.barplot(data=top_countries, x='Price', y='Country', palette='viridis')
plt.title('Total Sales by Country (Top 20)', fontsize=16)
plt.xlabel('Total Revenue')
plt.ylabel('Country')
plt.tight_layout()
plt.show()

"""Linear Regression visualisations"""

import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
from sklearn.metrics import r2_score, mean_squared_error

y_pred = model.predict(X_test)
r2 = r2_score(y_test, y_pred)  # Define R²
mse = mean_squared_error(y_test, y_pred)  # Define MSE

forecast_df = X_test.copy()
forecast_df['ActualSales'] = y_test.values
forecast_df['PredictedSales'] = y_pred
forecast_df['Date'] = monthly_sales['Date'].iloc[split_idx:].values

plot_df = forecast_df.melt(id_vars='Date',
                          value_vars=['ActualSales', 'PredictedSales'],
                          var_name='Type',
                          value_name='Sales')

# --- Plot with Metrics Annotation ---
plt.figure(figsize=(12, 6))
sns.lineplot(data=plot_df, x='Date', y='Sales', hue='Type',
             style='Type', markers=True, dashes=False)

# Add metrics box
metrics_text = f"R² = {r2:.3f}\nMSE = {mse:,.0f}"
plt.annotate(metrics_text,
             xy=(0.02, 0.85),
             xycoords='axes fraction',
             bbox=dict(boxstyle='round', facecolor='white', alpha=0.8),
             fontsize=12)

plt.title('Actual vs Predicted Monthly Sales', fontsize=16)
plt.xlabel('Date', fontsize=12)
plt.ylabel('Sales (£)', fontsize=12)
plt.xticks(rotation=45)
plt.grid(True, linestyle='--', alpha=0.3)
plt.tight_layout()
plt.show()

"""Average Sales Per Transaction by Month"""

plt.figure(figsize=(12, 6))
sns.barplot(x=monthly_sales['Date'].dt.strftime('%b %Y'), y='SalesPerTransaction', data=monthly_sales, palette='viridis')
plt.title('Average Sales Per Transaction by Month', fontsize=16)
plt.xlabel('Month')
plt.ylabel('Sales/Transaction (£)')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""Bubble Chart: Transactions vs Unique Customers (Bubble = Sales)"""

plt.figure(figsize=(12, 6))
sns.scatterplot(
    x='TransactionCount',
    y='UniqueCustomers',
    size='Sales',
    data=monthly_sales,
    sizes=(100, 1000),
    hue='Sales',
    palette='coolwarm',
    legend=False
)
plt.title('Bubble Chart: Transactions vs Unique Customers (Bubble = Sales)', fontsize=16)
plt.xlabel('Number of Transactions')
plt.ylabel('Unique Customers')
plt.grid(True)
plt.tight_layout()
plt.show()

"""Correlation Heatmap of Key Metrics"""

plt.figure(figsize=(8, 6))
sns.heatmap(
    monthly_sales[['Sales', 'TransactionCount', 'UniqueCustomers', 'TotalQuantity']].corr(),
    annot=True,
    cmap='coolwarm',
    center=0,
    linewidths=0.5,
    square=True
)
plt.title('Correlation Heatmap of Key Metrics', fontsize=16)
sns.despine()
plt.tight_layout()
plt.show()